# -*- coding: GBK -*-
# ---------------------------------------------------------------------------
# PointsClusterDefault.py
# Created on: 2015-07-02 11:08:02.00000
#   (generated by ArcGIS/ModelBuilder)
# Usage: PointsClusterDefault <InputExcel> <ClusterDistance> <OutPolygon> <OutPointsExcel> <OutPolygonsExecl> 
# Description: 
# ---------------------------------------------------------------------------

# Set the necessary product code
# import arcinfo


# Import arcpy module
import arcpy
from arcpy import env
import cx_Oracle
import re
import logging
import os
import os.path
import time,datetime
import httplib, urllib, json
import getpass

spatialReference = arcpy.SpatialReference(4326)
ArcCatalogPath = "C:\\Users\\Administrator\\AppData\\Roaming\\ESRI\\Desktop10.3\\ArcCatalog"
OracleGISDBPath = "PDB_PMSDB.sde"
LOG_FILE_NAME = "E:\\GisPython\\logs\\deleteLUCETable.log"
logging.basicConfig(filename=LOG_FILE_NAME,level=logging.INFO)
logging.basicConfig(filename=LOG_FILE_NAME,level=logging.ERROR)

username = "arcadmin"
password = "Passw0rd"
serverName = "10.48.186.82"
serverPort = 6080
serviceFolder = "/arcgis/admin/services/WangYou/"


def StopOrStartService(serviceFolder,serviceName,stopOrStart):
    token = getToken(username, password, serverName, serverPort)
    if token == "":
        print "Could not generate a token with the username and password provided."
        return
    # This request only needs the token and the response formatting parameter 
    params = urllib.urlencode({'token': token, 'f': 'json'})
    headers = {"Content-type": "application/x-www-form-urlencoded", "Accept": "text/plain"}
    # Connect to URL and post parameters    
    httpConn = httplib.HTTPConnection(serverName, serverPort)
    # Get a token
    fullSvcName = serviceName + "." + "MapServer"
    stopOrStartURL = serviceFolder+fullSvcName+"/" + stopOrStart
    httpConn.request("POST", stopOrStartURL, params, headers)
    # Read stop or start response
    stopStartResponse = httpConn.getresponse()
    if (stopStartResponse.status != 200):
        httpConn.close()
        print "Error while executing stop or start. Please check the URL and try again."
        return
    else:
        stopStartData = stopStartResponse.read()
        
        # Check that data returned is not an error object
        if not assertJsonSuccess(stopStartData):
            if str.upper(stopOrStart) == "START":
                print "Error returned when starting service " + fullSvcName + "."
            else:
                print "Error returned when stopping service " + fullSvcName + "."

            print str(stopStartData)
            
        else:
            print "Service " + fullSvcName + " processed successfully."

    httpConn.close()           
    return

# A function to generate a token given username, password and the adminURL.
def getToken(username, password, serverName, serverPort):
    # Token URL is typically http://server[:port]/arcgis/admin/generateToken
    tokenURL = "/arcgis/admin/generateToken"
    
    params = urllib.urlencode({'username': username, 'password': password, 'client': 'requestip', 'f': 'json'})
    
    headers = {"Content-type": "application/x-www-form-urlencoded", "Accept": "text/plain"}
    
    # Connect to URL and post parameters
    httpConn = httplib.HTTPConnection(serverName, serverPort)
    httpConn.request("POST", tokenURL, params, headers)
    
    # Read response
    response = httpConn.getresponse()
    if (response.status != 200):
        httpConn.close()
        print "Error while fetching tokens from admin URL. Please check the URL and try again."
        return
    else:
        data = response.read()
        httpConn.close()
        
        # Check that data returned is not an error object
        if not assertJsonSuccess(data):            
            return
        
        # Extract the token from it
        token = json.loads(data)        
        return token['token']            
        

# A function that checks that the input JSON object 
#  is not an error object.
def assertJsonSuccess(data):
    obj = json.loads(data)
    if 'status' in obj and obj['status'] == "error":
        print "Error: JSON object returns an error. " + str(obj)
        return False
    else:
        return True
    
if __name__ == '__main__':
    GIS_ZDLUCELOG = ArcCatalogPath+"\\"+OracleGISDBPath+"\\SDE.GIS_ZDLUCELOG"
    try:       
        print time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(time.time()))
        logging.info("开始时间:"+time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(time.time())))
        logging.info("STOP SERVICE ----------------------")
        StopOrStartService(serviceFolder,"LUCERSRP","stop")
        StopOrStartService(serviceFolder,"LUCERSRQ","stop")
        StopOrStartService(serviceFolder,"LUCESINR","stop")
        StopOrStartService(serviceFolder,"LUCEZCLD","stop")
        logging.info("DELETE TABLE ----------------------")
        taskCursor = arcpy.SearchCursor(GIS_ZDLUCELOG,"FLAG = 2")
        taskNextRow =  taskCursor.next()
        while taskNextRow:
            deleName = taskNextRow.GUANLIANTABLE
            deleTable = ArcCatalogPath+"\\"+OracleGISDBPath+"\\SDE."+deleName
            if(arcpy.Exists(deleTable)):
                print "delete exists "+deleName
                logging.info("delete exists table :"+deleName)
                arcpy.Delete_management(deleTable, "FeatureClass")
            taskNextRow = taskCursor.next()
        dbConnOra=cx_Oracle.connect("sde/sde_nsn2015@10.48.186.102:1521/pdb_pmsdb")
        cursorOra = dbConnOra.cursor()
        updateTaskState = "delete from GIS_ZDLUCELOG where FLAG=2"
        cursorOra.execute(updateTaskState)
        dbConnOra.commit()
        dbConnOra.close()
        logging.info("START SERVICE ----------------------")
        StopOrStartService(serviceFolder,"LUCERSRP","start")
        StopOrStartService(serviceFolder,"LUCERSRQ","start")
        StopOrStartService(serviceFolder,"LUCESINR","start")
        StopOrStartService(serviceFolder,"LUCEZCLD","start")        
        logging.info("结束时间:"+time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(time.time())))
        print "结束时间:"+time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(time.time()))
    except Exception,e:
        logging.error(e)
        print e.message
